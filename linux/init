#!/bin/busybox sh

# At this point, we only have:
#   /bin/busybox - the binary
#   /dev/console - the console device
BB=/bin/busybox

# Delete this file
# (Yes, we can do this on UNIX! The file is "removed"
# after the last reference, the fd, is gone.)
$BB rm /init

$BB find / -type f
$BB echo "Unlimited power!!"
# $BB poweroff -f
# ----------------------------------------------------
 
# "Create" command-line tools by making symbolic links
#   try: busybox --list
for cmd in $($BB --list); do
    $BB ln -s $BB /bin/$cmd
done

# Mount procfs and sysfs
mkdir -p /proc && mount -t proc  none /proc
mkdir -p /sys  && mount -t sysfs none /sys

# Create devices
mknod /dev/random  c 1 8
mknod /dev/urandom c 1 9
mknod /dev/null    c 1 3
mknod /dev/tty     c 4 1
mknod /dev/sda     b 8 0

echo -e "\033[31mInit OK; launch a shell (initramfs).\033[0m"

busybox sh

# Display a countdown

echo -e "\n\n"
echo -e "\033[31mSwitch root in...\033[0m"
for sec in $(seq 3 -1 1); do
    echo $sec; sleep 1
done

# Switch root to /newroot (a real file system)
N=/newroot
#此处将制造一个真正的文件系统
mkdir -p $N
mount -t ext4 /dev/sda $N #挂载之前制造文件系统镜像

mkdir -p $N/bin
cp $BB $N/bin/ # 把bin什么的拷贝进去
cp $BB /init
exec switch_root /newroot/ /init  #本来新的文件系统是挂载在initramfs上，现在是要把文件系统的根切换到新的文件系统上。
# 调用pivot_root, 必须用exec，因为该系统调用进程号必须是1，如果去掉就是先fork再exec了，会失败，事实上，操作系统当且仅当在这个时候使用这个系统调用
# （这个init进程进程号就是1）

# 执行完成之后，就进入了一个可以持久化的“完整的”操作系统，（QEMU）下，就是一个比较完整的虚拟机了！
# 这里有一个问题，就是这个转换后是在执行什么进程？还是init,我们这里执行的是fsroot下的init`
# 现代的Linux在这一步之后会去寻找 /sbin/init 并执行它，这个init指向systemd（pid还是1）(内核守护进程)
